#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <ctype.h>
#include <stdlib.h>
#include <iomanip>
#include "Morada.h"
#include "Client.h"
#include "Agency.h"
#include "PAcotes.h"
#include "Data.h"

using namespace std;

void menu(vector <Client>&, vector <Pacotes>&, string&);

void estatisticasmenu(vector <Client>, vector <Pacotes>, string);

//-------------------------AUXILIAR----------------------------------

/*funcao que verifica se um ano e bissexto
@param1 recebe como parametro um ano
*/
bool bissexto(int ano) {
	//formulas que verificam se um ano e bissexto
	if (ano % 4 == 0 && ano % 100 != 0)
		return true;
	else if (ano % 100 == 0 && ano % 400 == 0)
		return true;
	else
		return false;
}

//ve se uma data existe
//@param1 recebe como parametro o ano
//@param2 recebe como parametro mes
//@param3 recebe como parametro o dia
bool validdate(int ano, int mes, int dia) {
	if (mes < 1 || mes > 12)
		return false;
	else {
		switch (mes) {
		case 1:
			if (dia < 1 || dia > 31)
				return false;
			break;
		case 2:
			if (bissexto(ano) == true) {
				if (dia < 1 || dia > 29)
					return false;
			}
			else
				if (dia < 1 || dia > 28)
					return false;
			break;
		case 3:
			if (dia < 1 || dia > 31)
				return false;
			break;
		case 4:
			if (dia < 1 || dia > 30)
				return false;
			break;
		case 5:
			if (dia < 1 || dia > 31)
				return false;
			break;
		case 6:
			if (dia < 1 || dia > 30)
				return false;
			break;
		case 7:
			if (dia < 1 || dia > 31)
				return false;
			break;
		case 8:
			if (dia < 1 || dia > 31)
				return false;
			break;
		case 9:
			if (dia < 1 || dia > 30)
				return false;
			break;
		case 10:
			if (dia < 1 || dia > 31)
				return false;
			break;
		case 11:
			if (dia < 1 || dia > 30)
				return false;
			break;
		case 12:
			if (dia < 1 || dia > 31)
				return false;
			break;

		}
	}
	return true;
}

//verifica se um codigo postal e valido e retir os espacos interiores e iniciais e finais a mais
//@param1 introduzido pelo utlizador
//@param2 resultante
bool validcodpostal(string codpostalu, string & codpostal) {
	codpostal = "";
	int cont = 0;
	for (int i = 0; i < codpostalu.length(); i++) {
		if (isdigit(codpostalu[i]))  //se for numero
			codpostal += string(1, codpostalu[i]);
		else if (codpostalu[i] == '-') {
			codpostal += string(1, codpostalu[i]);
			cont++;
			//se houver mais que 1 - nao e valido
			if (cont > 2)
				return false;
		}
		//se for um carater diferente de numero espaco ou - nao e valido
		else if (codpostalu[i] != ' ')
			return false;
	}
	//se nao tiver escrito nada ou se nao tiver - nao e valido
	if (codpostal == "" || cont == 0)
		return false;
	//se tiver um - no inicio ou no fim nao e valido
	else if (codpostal[0] == '-' || codpostal[codpostal.length() - 1] == '-')
		return false;
}

//transforma a listagem de pacotes num vetor
//@param1 uma string comos pacotes
vector <string> tovector(string pacotes) {
	string aux = "";
	vector <string> a;
	if (pacotes == "-")
		return a;
	for (int i = 0; i < pacotes.length(); i++) {
		if (!isdigit(pacotes[i]) && aux != " ") {
			a.push_back(aux);
			aux = "";
		}
		else
			aux += string(1, pacotes[i]);
	}
	a.push_back(aux);
	return a;
}

//cria um vetor com todos os codigos dos pacotes
//@param1 vetor com informacao dos pacotes
vector <string> codvector(vector <Pacotes> pacote) {
	vector <string> aux;
	for (int i = 0; i < pacote.size(); i++)
		aux.push_back(pacote[i].getId());
	return aux;

}

//diz se um valor esta no vetor ou nao
//@param1 vetor com os codigos dos pacotes
//@param2 valor a verificar
bool invector(vector <string> codigos, string verif) {
	bool pres = false; //assumo que o valor incialmente nao esta no vetor
	for (int i = 0; i < codigos.size(); i++) {
		if (codigos[i] == verif) {
			pres = true;   // se sim coloca pres em true e sai do ciclo
			break;
		}
	}
	return pres;
}

//retorna o indice de um valor num vetor
//@param1 vetor com os codigos dos pacotes
//@param2 valor a encontrar
int indexcod(vector <string> codigos, string valor) {
	int index;
	for (int i = 0; i < codigos.size(); i++) {
		if (codigos[i] == valor) {
			index = i;
			return index;
		}
	}
}

//mostra os nomes dos clientes
//@param1 vetor com informacao dos clientes
void mostranomes(vector <Client> a) {
	cout << endl << endl;
	for (int i = 0; i < a.size(); i++) {
		cout << i + 1 << ") " << a[i].getNome() << endl;
	}
}

//cria um vetor com os pacotes atualmente disponiveis
//@param1 vetor com os pacotes
vector <Pacotes> dispac(vector <Pacotes> pacotes) {
	vector <Pacotes> disponiveis;
	for (int i = 0; i < pacotes.size(); i++) {
		if (pacotes[i].getId()[0] != '-')
			disponiveis.push_back(pacotes[i]);
	}
	return disponiveis;
}

//tira os espaÃ§os a mais no inicio e no fim
//@param1 recebe uma palavra para normalizar
string normalise(string palavra) {
	string aux;
	int cont = 0, inicio, fim;
	//se nao introziu nada apenas enter
	if (palavra.length() == 0)
		return "";
	else {
		//conta os espacos na string
		for (int i = 0; i < palavra.length(); i++) {
			if (palavra[i] == ' ')
				cont++;
		}
	}
	//se ela for so espacos ou seja se o seu comprimento for igual ao numero de espacos retorna vazia
	if (cont == palavra.length())
		return "";
	else {
		//ve onde ocorreu o primeiro nao espaco e guarda em indice
		for (int k = 0; k < palavra.length(); k++) {
			if (palavra[k] != ' ') {
				inicio = k;
				break;
			}
		}
		//ve onde ocorreu o ultimo nao espaco e guarda em fim
		for (int i = palavra.length() - 1; i > -1; i--) {
			if (palavra[i] != ' ') {
				fim = i;
				break;
			}
		}
		aux = palavra;
		palavra = "";
		//escreve a palavra sem os espacos
		for (int i = inicio; i < fim + 1; i++) {
			palavra += aux[i];
		}
		return palavra;
	}
}

//verifica se uma data contem ou nao carateres e normaliza - a
//@param1 ano inrroduzido pelo utilizador
//@param2 mes introduzido pelo utilizador
//@param3 dia introduzido pelo utilizador
//@param4 ano normalziado
//@param5 mes normalziado
//@param6 dia normalziado
bool validdigit(string number1, string number2, string number3, string & retano, string & retmes, string & retdia) {
	retano = "";
	retmes = "";
	retdia = "";
	//verificacao ano
	for (int i = 0; i < number1.length(); i++) {
		if (isdigit(number1[i]))
			retano += string(1, number1[i]);
		else if (number1[i] != ' ')
			return false;
	}
	if (retano == "")
		return false;
	//verificacao mes
	for (int i = 0; i < number2.length(); i++) {
		if (isdigit(number2[i]))
			retmes += string(1, number2[i]);
		else if (number2[i] != ' ')
			return false;
	}
	if (retmes == "")
		return false;
	//verificacao dia
	for (int i = 0; i < number3.length(); i++) {
		if (isdigit(number3[i]))
			retdia += string(1, number3[i]);
		else if (number3[i] != ' ')
			return false;
	}
	if (retdia == "")
		return false;
	return true;     //se todos tiverem sido introduzidos corretamente
}

//verifica se um nome nao contem carateres invalidos
//@param1 string introduzida pelo utlizador
bool validname(string nome) {
	for (int i = 0; i < nome.length(); i++) {
		if (!isalpha(nome[i]) && nome[i] != ' ')
			return false;
	}
	//se nao tiver escrito nada retorna falso
	if (normalise(nome) == "")
		return false;
	return true;
}

//verifica se um numero e valido e remove os espacos entre numeros
//@param1 numero introduzido pelo utilizador
//@param2 numero resultante
bool validnum(string numu, string & num) {
	num = "";
	for (int i = 0; i < numu.length(); i++) {
		if (isdigit(numu[i]))
			num += string(1, numu[i]);
		else if (numu[i] != ' ')
			return false;
	}
	if (num == "")
		return false;
	return true;
}

//verifica se um andar e valid ou seja se nao contem carateres invalidos neste campo
//@param1 introduzido pelo utlizador
//@param2 resultante
bool validandar(string aux, string & fin) {
	int indice, cont = 0;
	aux = normalise(aux);
	//se nao tiver escrito nada retorna falso
	if (aux == "")
		return false;
	//se nao tiver nenhum andar
	if (normalise(aux) == "-") {
		fin = aux;
		return true;
	}
	fin = "";
	for (int i = 0; i < aux.length(); i++) {
		if (isdigit(aux[i]))
			cont++;
		if (isdigit(aux[i]) || isalpha(aux[i]) || aux[i] == ' ') {  //so podem ser destes tipos os carateres
			if (fin.length() == 0 && isalpha(aux[i]))    //nao pode ser logo o local: esquerda ou direita ou traseiras ou frente
				return false;
			else if (fin.length() == 0 && isdigit(aux[i]))   //se for um numero escreve
				fin += string(1, aux[i]);
			else if (fin.length() != 0) {
				if (isdigit(aux[i]) && isalpha(fin[fin.length() - 1]))   //nao pode ter um numero depois de uma letra
					return false;
				else if (aux[i] != ' ')
					fin += string(1, aux[i]);
			}
		}
	}
	//se nao tiver nenhum numero retorna falso
	if (cont == 0)
		return false;
	//se so tiver numeros
	if (fin.length() == cont)
		return true;
	//ve onde surgiu a primeria letra
	for (int k = 0; k < fin.length(); k++) {
		if (!isdigit(fin[k])) {
			indice = k;
			break;
		}
	}
	aux = fin;
	fin = "";
	//coloca essa primeria em letra grande
	for (int i = 0; i < indice + 3; i++) {
		if (i == indice)
			fin += string(1, toupper(aux[i]));
		else
			fin += string(1, aux[i]);
	}
	return true;
}

//verfica se a lista de pacotes adquiridos e valida se nao introduziu nenhuma letra ou coisas do genero
//@param1 pacotes introduzidos pelo utilizador
//@parm2 pacotes resultantes
bool validpacadq(string pacadqu, string & pacadq) {
	pacadq = "";
	for (int i = 0; i < pacadqu.length(); i++) {
		if (isdigit(pacadqu[i]))
			pacadq += string(1, pacadqu[i]);
		else if (pacadqu[i] == ';' || pacadqu[i] == ',')
			pacadq += " ; ";
		else if (pacadqu[i] == '-')
			pacadq += "-";
		else if (pacadqu[i] != ' ')
			return false;
	}
	return true;
}

//coloca as letras iniciais em maiusculas
//@param1 nome a alterar
void legra(string & nome) {
	string aux = "";
	vector <string> param;
	//cria um vetor com a string
	for (int i = 0; i < nome.length(); i++) {
		if (nome[i] != ' ')
			aux += string(1, nome[i]);
		else {
			param.push_back(aux);
			aux = "";
		}
	}
	param.push_back(aux);
	nome = "";
	//coloca em letra grande todas as palavras que nao sejam de, o, da, dos ,des
	for (int i = 0; i < param.size(); i++) {
		if (param[i] != "de" && param[i] != "do" && param[i] != "dos" && param[i] != "da" && param[i] != "das")
			for (int k = 0; k < param[i].length(); k++) {
				if (k == 0)
					nome += string(1, toupper(param[i][k]));
				else
					nome += string(1, param[i][k]);
			}
		else
			nome += param[i];
		nome += " ";
	}
	nome = normalise(nome);  //retira os espacos a mais
}

//apaga espaÃ§os intermedios que estejam a mais e coloca em grande o necessario incovando outra funcao
//@param1 nome com espacos a mais
//@param2 string normalizada
void espaint(string aux, string & nome) {
	nome = "";
	int espacos = 0;
	//retira os espacos a mais
	for (int i = 0; i < aux.length(); i++) {
		if (isalpha(aux[i])) {
			if (espacos != 0)
				espacos = 0;
			nome += string(1, aux[i]);
		}
		else {
			espacos++;
			if (espacos == 1)
				nome += " ";
		}
	}
	nome = normalise(nome);   //retira pos espacos que possam ter ficado a mais devido a concatenacao
	legra(nome);     //invoca para colocar em grande 
}

//verifica se um destino e valido e normaliza-o colocando o necessario em maiusculas
//@param1 introduzido pelo utlizador
//@param2 resultante
bool validdest(string destu, string & dest) {
 	string aux = "";
	dest = "";
	vector <string> param;
	//cria um vetor com as palavras, virgulas e - e retorna falso se houver algum caratere que nao seja letras, virgulas ou -
	for (int i = 0; i < destu.length(); i++) {
		if (isalpha(destu[i]) || destu[i] == ' ')
			aux += destu[i];
		else if (destu[i] == '-' || destu[i] == ',') {
			param.push_back(normalise(aux));   //adiciona a palavra normalizada
			param.push_back(string(1, destu[i]));  //adiciona virgula ou -
			aux = "";
		}
		else
			return false;
	}
	param.push_back(normalise(aux));
	//vai a cada elemento do vetor e...	
	for (int i = 0; i < param.size(); i++) {
		if (param[i] != "-" && param[i] != ",") {
			espaint(param[i], aux); //coloca em grande o necessario e retira os espacos desnecessarios o meio
			dest += " " + aux;
		}
		else if (param[i] == "-")
			dest += " -";
		else
			dest += ",";

	}
	dest = normalise(dest);    //retira o espaco que fica a mais no inicio
	return true;
}

//verifica se um codigo e valido e normaliza-o
//@param1 introduzido pelo utlizador
//@param2 resultante
bool lecopac(string aux, string & nome) {
	nome = "";
	for (int i = 0; i < aux.length(); i++) {
		if ((aux[i] == '-' && nome == "") || isdigit(aux[i]))
			nome += string(1, aux[i]);
		else
			return false;
	}
	return true;
}

//---------------------VISUALIZACAO DE INFORMACAO-------------------------

//visualiza a infor macao sobre um cliente especifico
//@param1 vetor com informacao dos clientes
//@param2 vetor com informacao dos pacotes
//@param3 string com informacao do ultimo a ser criado
void clienteesp(vector <Client> cliente, vector <Pacotes> pacote, string imp) {
	char cont;
	int indice;
	cout << "\n\n##########################################################################################";
	cout << endl << endl << "\t\t\tINFORMACAO DE UM CLIENTE ESPECIFICO\n" << endl;
	//mostra os nomes ods clietes atuais
	for (int i = 0; i < cliente.size(); i++) {
		cout << i + 1 << ")" << cliente[i].getNome() << ";\n";
	}
	cout << cliente.size() + 1 << ")Voltar;\n";
	cout << "\nIntroduza a opcao referente a sua escolha: ";
	cin >> indice;
	//Deteta se houve algum erro no input de dados
	while (cin.fail() || indice < 1 || indice > cliente.size() + 1) {
		cin.clear();
		cin.ignore(1000, '\n');
		cout << "Opcao Invalida!\nTente novamente: ";
		cin >> indice;
	}
	cin.ignore(1000, '\n');
	if (cliente.size() + 1 == indice)
	{
		estatisticasmenu(cliente, pacote, imp);
		return;
	}
	cout << endl;
	cliente[indice - 1].showClient();
}

//mostra informacao de todos os clientes
//@param1 vetor com informacao dos clientes
//@param2 vetor com informacao dos pacotes
//@param3 string com informacao do ultimo a ser criado
void clienteger(vector <Client> cliente, vector <Pacotes> pacote, string imp) {
	char cont;
	cout << "\n\n##########################################################################################";
	cout << endl << endl << "\t\t\tINFORMACAO DE TODOS OS CLIENTES \n\n";
	for (int i = 0; i < cliente.size(); i++) {
		cout << "Cliente " << i + 1 << " \n";
		cliente[i].showClient();
	}
}

//Informacao sobre pacotes adquiridos por um determinado cliente
//@param1 vetor com informacao dos clientes
//@param2 vetor com informacao dos pacotes
//@param3 string com informacao do ultimo a ser criado
void clivend(vector <Client> cliente, vector <Pacotes> pacote, string imp) {
	char cont;
	int indice;
	vector <string> aux;
	cout << "\n\n##########################################################################################";
	cout << endl << endl << "\t\t\PACOTES VENDIDOS A UM DETERMINADO CLIENTE\n\n";
	cout << "CLIENTES\n\n";
	//mostra os clientes
	for (int i = 0; i < cliente.size(); i++) {
		cout << i + 1 << ")" << cliente[i].getNome() << ";\n";
	}
	cout << "\nIntroduza a opcao referente ao cliente que deseja saber: ";
	cin >> indice;
	cout << endl;
	//deteta se ocorreu algum problema com o input
	while (cin.fail() || indice < 1 || indice > cliente.size()) {
		cin.clear();
		cin.ignore(1000, '\n');
		cout << "Opcao Invalida!\nTente novamente: ";
		cin >> indice;
		cout << endl;
	}
	cin.ignore(1000, '\n');
	//coloca os vetores adquiridos  num vetor
	aux = tovector(cliente[indice - 1].getPacotAdquiridos());
	cout << endl << endl << "Pacotes Adquiridos por: " << cliente[indice - 1].getNome() << "\n\n";
	//mostra os pacotes adquiridos
	//se tiver algum
	if (!aux.empty()) {
		//cilo para os pacotes
		for (int i = 0; i < pacote.size(); i++) {
			//cilo para os pacotes do cliente
			for (int k = 0; k < aux.size(); k++) {
				//ve se ha algum dos codigos nos pacotes caso estejam disponiveis
				if (pacote[i].getId() == aux[k]) {
					pacote[i].showPacote();
				}
				//ve se ha algum dos codigos nos pacotes caso estejam indisponiveis
				else if (pacote[i].getId()[0] == '-' && pacote[i].getId().substr(1) == aux[k]) {
					pacote[i].showPacote();
				}
			}
		}
	}
	// se nao tiver nenhum
	else
		cout << "Nao adquiriu nenhum pacote!";
}

//Informacao sobre os pacotes vendidos a todos os clientes
//@param1 vetor com informacao dos clientes
//@param2 vetor com informacao dos pacotes
//@param3 string com informacao do ultimo a ser criado
void todvend(vector <Client> cliente, vector <Pacotes> pacote, string imp) {
	char cont;
	int indice;
	vector <string> aux;
	cout << "\n\n##########################################################################################";
	cout << endl << endl << "\t\t\tPACOTES ADQUIRIDOS\n\n";
	//ciclo para todos os clientes
	for (int i = 0; i < cliente.size(); i++) {
		cout << endl << endl << "Pacotes adquiridos por: " << cliente[i].getNome() << endl << endl;
		aux = tovector(cliente[i].getPacotAdquiridos());
		//se o cliente tiver adquirido algum pacote
		if (!aux.empty()) {
			//ciclo para todos os pacotes
			for (int j = 0; j < pacote.size(); j++) {
				//ciclo para todos os pacotes que oc liente adquiriu
				for (int k = 0; k < aux.size(); k++) {
					//todos os que foram adquiridos e estao disponiveis
					if (pacote[j].getId() == aux[k]) {
						pacote[j].showPacote();
						cout << endl;
					}
					//todos os que adquiriram e que estao indisponiveis
					else if (pacote[j].getId()[0] == '-' && pacote[j].getId().substr(1) == aux[k]) {
						pacote[j].showPacote();
						cout << endl;
					}
				}
			}
		}
		else
			cout << "Nao adquiriu nenhum pacote!";
	}
}

//mostra quais os pacotes disponiveis
//@param1 vetor com informacao dos clientes
//@param2 vetor com informacao dos pacotes
//@param3 string com informacao do ultimo a ser criado
void disp(vector <Client> cliente, vector <Pacotes> pacote, string imp) {
	cout << "\n\n##########################################################################################";
	cout << endl << endl << "\t\t\tPACOTES DISPONIVEIS\n\n";
	for (int i = 0; i < pacote.size(); i++) {
		if (pacote[i].getId()[0] != '-') {
			pacote[i].showPacote();
			cout << endl;
		}
	}
}

//mostra pacote relativo a um destino especifico
//@param1 vetor com informacao dos clientes
//@param2 vetor com informacao dos pacotes
//@param3 string com informacao do ultimo a ser criado
void destesp(vector <Client> cliente, vector <Pacotes> pacote, string imp) {
	char cont;
	int indice;
	vector <Pacotes> disponiveis;
	cout << "\n\n##########################################################################################";
	cout << "\n\n\t\t\tPACOTES DISPONIVEIS REFERENTES A UM DESTINO ESPECIFICO\n\n";
	//forma um vetor com os pacotes disponiveis
	disponiveis = dispac(pacote);
	//mostra todos os destinos que estao disponiveis
	for (int i = 0; i < disponiveis.size(); i++)
		cout << i + 1 << ")" << disponiveis[i].getDestino() << ";\n";
	cout << "\nDigite o numero correspondente a sua escolha: ";
	cin >> indice;
	//Deteta se houve erro
	while (cin.fail() || indice < 1 || indice > pacote.size()) {
		cin.clear();
		cin.ignore(1000, '\n');
		cout << "Opcao Invalida!\nTente novamente: ";
		cin >> indice;
		cout << endl;
	}
	cin.ignore(1000, '\n');
	//mostra o pacote referente ao destino escolhido
	cout << endl << "Relativo ao seguinte destino: " << disponiveis[indice - 1].getDestino() << endl << endl;
	disponiveis[indice - 1].showPacote();
}

//mostra o pacote refernte ao destino escolhido entre duas datas
//@param1 vetor com informacao dos clientes
//@param2 vetor com informacao dos pacotes
//@param3 string com informacao do ultimo a ser criado
void dudat(vector <Client> cliente, vector <Pacotes> pacote, string imp) {
	int cont = 1;
	vector <Pacotes> disponiveis;
	bool invalid = true;
	string anopar, mespar, diapar, anoche, mesche, diache; //servem para recolher os anos meses e dias introduzidos pelo utilizador
	int dataparu, datacheu, dataparpac, datachepac; //cria um numero concatenando as string das datas referentes as de partida e chegada do utilizador(2 iniciais) e as duas finais relativas aos pacotes
	string aux, aux1, aux2;   //auxilia a leitura de dados
	cout << "\n\n##########################################################################################";
	cout << endl << endl << "\t\t\tPACOTES DISPONIVEIS ENTRE DUAS DATAS\n\n";
	//so sai do ciclo quando as datas inserirem forem validas
	//verifica se as datas sao validas
	while (invalid)
	{
		cout << "Introduza a data de partida no formato ano/mes/dia: ";
		getline(cin, aux, '/');
		getline(cin, aux1, '/');
		getline(cin, aux2);
		//verifica se sao inteiros
		while (!validdigit(aux, aux1, aux2, anopar, mespar, diapar)) {
			cerr << "\nIntroduziu carateres invalidos no campo data! Tente novamente!\n";
			cout << "Introduza a data de partida no formato ano/mes/dia: ";
			getline(cin, aux, '/');
			getline(cin, aux1, '/');
			getline(cin, aux2);
		}
		//caso seja 6 fica 06
		if (mespar.length() == 1)
			mespar = "0" + mespar;
		if (diapar.length() == 1)
			diapar = "0" + diapar;
		cout << "Introduza a data de chegada no formato ano/mes/dia: ";
		getline(cin, aux, '/');
		getline(cin, aux1, '/');
		getline(cin, aux2);
		//verifica se sao inteiros
		while (!validdigit(aux, aux1, aux2, anoche, mesche, diache)) {
			cerr << "\nIntroduziu carateres invalidos no campo data! Tente novamente!\n";
			cout << "Introduza a data de partida no formato ano/mes/dia: ";
			getline(cin, aux, '/');
			getline(cin, aux1, '/');
			getline(cin, aux2);
		}
		//caso seja 6 fica 06
		if (mesche.length() == 1)
			mesche = "0" + mesche;
		if (diache.length() == 1)
			diache = "0" + diache;
		dataparu = stoi(anopar + mespar + diapar);
		datacheu = stoi(anoche + mesche + diache);
		//verifica se a data de chegada e antes da de partida ou se alguma das datas nao existe
		if (validdate(stoi(anopar), stoi(mespar), stoi(diapar)) == false || validdate(stoi(anoche), stoi(mesche), stoi(diache)) == false || datacheu < dataparu) {
			cout << "\nInseriu pelo menos uma data incorreta! Tente novamente!";
			cout << endl;
		}
		else
			invalid = false;
	}
	cout << endl;
	disponiveis = dispac(pacote);
	//mostra os pacotes disponiveis entre as datas do utilizador
	for (int i = 0; i < disponiveis.size(); i++) {
		dataparpac = stoi(disponiveis[i].getAnoInicio() + disponiveis[i].getMesInicio() + disponiveis[i].getDiaInicio());
		datachepac = stoi(disponiveis[i].getAnoFim() + disponiveis[i].getMesFim() + disponiveis[i].getDiaFim());
		//so faz isto se a partida do utilizador for antes da do  pacote ou a de chegada do pacote for antes do utilizador
		if (dataparu <= dataparpac && datachepac <= datacheu) {
			cout << "Pacote " << cont << endl << endl;
			disponiveis[i].showPacote();
			cont++;
		}
	}
	//caso nao hajam pacotes disponiveis
	if (cont == 1)
		cout << "Nao ha pacotes disponiveis entre essas duas datas!";
}

//mostra o pacote disponivel relativo a um destino e data especifica
//@param1 vetor com informacao dos clientes
//@param2 vetor com informacao dos pacotes
//@param3 string com informacao do ultimo a ser criado
void destespdudat(vector <Client> cliente, vector <Pacotes> pacote, string imp) {
	int cont = 1, opcao;
	bool invalid = true;
	vector <Pacotes> disponiveis;
	string anopar, mespar, diapar, anoche, mesche, diache; //servem para recolher os anos meses e dias introduzidos pelo utilizador
	string aux, aux1, aux2;   // auxilia a leitura de dados
	int dataparu, datacheu, dataparpac, datachepac; //cria um numero concatenando as string das datas referentes as de partida e chegada do utilizador(2 iniciais) e as duas finais relativas aos pacotes
	cout << "\n\n##########################################################################################";
	cout << endl << endl << "\t\t\tPACOTES DISPONIVEIS EM RELACAO A DUAS DATAS E UM DESTINO ESPECIFICO\n\n";
	//deteta se as datas sao validas
	while (invalid)
	{
		cout << "Introduza a data de partida no formato ano/mes/dia: ";
		getline(cin, aux, '/');
		getline(cin, aux1, '/');
		getline(cin, aux2);
		//verifica se os digitos sao inteiros
		while (!validdigit(aux, aux1, aux2, anopar, mespar, diapar)) {
			cout << "\nInseriu carateres que nao pertencem a uma data deste formato! Tente novamente!\n";
			cout << "Introduza a data de partida no formato ano/mes/dia: ";
			getline(cin, aux, '/');
			getline(cin, aux1, '/');
			getline(cin, aux2);
		}
		//caso seja 6 passa a 06
		if (mespar.length() == 1)
			mespar = "0" + mespar;
		if (diapar.length() == 1)
			diapar = "0" + diapar;
		cout << "Introduza a data de chegada no formato ano/mes/dia: ";
		getline(cin, aux, '/');
		getline(cin, aux1, '/');
		getline(cin, aux2);
		//verifica se os digitos sao inteiros
		while (!validdigit(aux, aux1, aux2, anoche, mesche, diache)) {
			cout << "\nInseriu carateres que nao pertencem a uma data deste formato! Tente novamente!\n";
			cout << "Introduza a data de partida no formato ano/mes/dia: ";
			getline(cin, aux, '/');
			getline(cin, aux1, '/');
			getline(cin, aux2);
		}
		//caso seja 6 passa a 06
		if (mesche.length() == 1)
			mesche = "0" + mesche;
		if (diache.length() == 1)
			diache = "0" + diache;
		dataparu = stoi(anopar + mespar + diapar);
		datacheu = stoi(anoche + mesche + diache);
		//verifica se a data de chegada e antes da de partida ou se houve algum erro com alguma data
		if (validdate(stoi(anopar), stoi(mespar), stoi(diapar)) == false || validdate(stoi(anoche), stoi(mesche), stoi(diache)) == false || datacheu < dataparu) {
			cout << "\nInseriu pelo menos umda data incorreta! Tente novamente!";
			cout << endl;
		}
		else
			invalid = false;
	}
	cout << endl;
	//forma os destinos disponiveis entre as datas
	disponiveis = dispac(pacote);
	//mostra os disponiveis entre as datas 
	for (int i = 0; i < disponiveis.size(); i++) {
		dataparpac = stoi(disponiveis[i].getAnoInicio() + disponiveis[i].getMesInicio() + disponiveis[i].getDiaInicio());
		datachepac = stoi(disponiveis[i].getAnoFim() + disponiveis[i].getMesFim() + disponiveis[i].getDiaFim());
		//so faz isto se a partida do utilizador for antes da do  pacote ou a de chegada do pacote for antes do utilizador
		if (dataparu <= dataparpac && datachepac <= datacheu) {
			cout << cont << ")" << disponiveis[i].getDestino() << endl;
			cont++;
		}
	}
	//ja que se houver pelo menos um pacote disponivel o cont fica pelo menos a dois entao se houver pacotes faz isto
	if (cont != 1) {
		//o utilizador seleciona um
		cout << "\n\nDigite o numero correspondente a sua opcao: ";
		cin >> opcao;
		while (opcao < 1 || opcao > disponiveis.size() || cin.fail()) {
			cin.clear();
			cin.ignore(1000, '\n');
			cerr << "Opcao invalida!\nTente novamente: ";
			cin >> opcao;
		}
		cout << endl << endl;
		disponiveis[opcao - 1].showPacote();
		cin.ignore(1000, '\n');
	}
	//se nao faz isto
	else
		cout << "Nao ha pacotes disponiveis entre essas duas datas!";
}

//diz qual foi o numero de pacotes e lucro obtidos
//@param1 vetor com informacao dos clientes
//@param2 vetor com informacao dos pacotes
//@param3 string com informacao do ultimo a ser criado
void vendluc(vector <Client> cliente, vector <Pacotes> pacote, string imp) {
	char cont;
	int soma = 0, lucro = 0, pacvend = 0;
	cout << "\n\n##########################################################################################";
	cout << endl << endl << "\t\t\tINFORMACAO SOBRE VENDAS E LUCRO DOS PACOTES\n\n";
	for (int i = 0; i < pacote.size(); i++) {
		if (pacote[i].getId()[0] == '-') {
			//soma os pacotes esgotados
			pacvend++;
			//Calcula o preco total de cada pacote esgtado e soma-os 
			lucro += stoi(pacote[i].getLugaresV()) * stoi(pacote[i].getPreco());
		}
	}
	cout << "PACOTES ESGOTADOS............................: " << pacvend;
	cout << "\nLUCRO TOTAL EM EUROS(REFERENTE AOS ESGOTADOS): " << lucro;
}

//-------------------------CLIENTES-------------------------

//cria um novo cliente
//@param1 vetor que contem informaÃ§ao dos clietes e e alterado
//@param2 vetor  que contem informaÃ§ao sobre pacotes
//@param3 string com informacao do ultimo a ser criado
void cricli(vector <Client> & cliente, vector <Pacotes> pacote, string imp) {
	cout << endl;
	Client novo;
	string aux;   //auxilia leitura de dados
	string nome, rua, nif, agreg, pac, porta, localidade, codpostal, andar, capgasto;   //auxilia leitura de dados
	cout << "\n\n##########################################################################################";
	cout << endl << endl << "\t\t\tCRIACAO DE CLIENTES\n\n";
	cout << "Introduza o nome: ";
	getline(cin, aux);
	//verifica se ocorreu algum erro
	while (validname(normalise(aux)) == false) {
		cerr << "\nIntroduziu carateres invalidos no campo nome!Tente novamente!";
		cout << "\nIntroduza o nome: ";
		getline(cin, aux);
	}
	espaint(normalise(aux), nome);
	novo.setNome(nome);
	cout << "Introduza o NIF: ";
	getline(cin, aux);
	//verifica se ocorreu algum erro
	while (validnum(aux, nif) == false || nif.length() != 9) {
		if (validnum(aux, nif) == false) {
			cerr << "\nIntroduziu carateres invalidos no campo NIF!Tente novamente!";
			cout << "\nIntroduza o NIF: ";
			getline(cin, aux);
		}
		else if (nif.length() < 9) {
			cerr << "\nIntroduziu carateres a menos no campo NIF!Tente novamente!";
			cout << "\nIntroduza o NIF: ";
			getline(cin, aux);
		}
		else {
			cerr << "\nIntroduziu carateres a mais no campo NIF!Tente novamente!";
			cout << "\nIntroduza o NIF: ";
			getline(cin, aux);
		}
	}
	novo.setNif(nif);
	cout << "Introduza o agregado familiar: ";
	getline(cin, aux);
	//verifica se ocorreu algum erro
	while (validnum(aux, agreg) == false) {
		cerr << "\nIntroduziu carateres invalidos no campo agregado familiar!Tente novamente!";
		cout << "\nIntroduza o agregado familiar: ";
		getline(cin, aux);
	}
	novo.setAgregFamiliar(agreg);
	cout << "Introduza a rua: ";
	getline(cin, aux);
	//verifica se ocorreu algum erro
	while (validname(normalise(aux)) == false) {
		cerr << "\nIntroduziu carateres invalidos no campo rua!Tente novamente!";
		cout << "\nIntroduza a rua: ";
		getline(cin, aux);
	}
	espaint(normalise(aux), rua);
	novo.setMoradaRua(rua);
	cout << "Introduza o numero da porta: ";
	getline(cin, aux);
	//verifica se ocorreu algum erro
	while (validnum(aux, porta) == false) {
		cerr << "\nIntroduziu carateres invalidos no campo porta!Tente novamente!";
		cout << "\nIntroduza o numero da porta: ";
		getline(cin, aux);
	}
	novo.setMoradaPorta(porta);
	cout << "Introduza o andar(se n tiver andar digite -): ";
	getline(cin, aux);
	//verifica se ocorreu algum erro
	while (validandar(aux, andar) == false) {
		cerr << "\nIntroduziu carateres invalidos no campo andar!Tente novamente!";
		cout << "\nIntroduza o andar: ";
		getline(cin, aux);
	}
	novo.setMoradaAndar(andar);
	cout << "Introduza o codigo postal: ";
	getline(cin, aux);
	//verifica se ocorreu algum erro
	while (validcodpostal(aux, codpostal) == false) {
		cerr << "\nIntroduziu carateres invalidos no campo codigo postal!Tente novamente!";
		cout << "\nIntroduza o codigo postal: ";
		getline(cin, aux);
	}
	novo.setMoradaCPostal(codpostal);
	cout << "Introduza a localidade: ";
	getline(cin, aux);
	//verifica se ocorreu algum erro
	while (validname(normalise(aux)) == false) {
		cerr << "\nIntroduziu carateres invalidos no campo localidade!Tente novamente!";
		cout << "\nIntroduza a localidade: ";
		getline(cin, aux);
	}
	espaint(normalise(aux), localidade);
	novo.setMoradaLocalidade(localidade);
	cout << "Introduza o codigo dos pacotes que ja adquiriu(se nao adquiriu nenhum ou se vai adquirir agora um, digite -): ";
	getline(cin, aux);
	//verifica se ocorreu algum erro
	while (validpacadq(aux, pac) == false) {
		cerr << "\nIntroduziu carateres invalidos no campo pacotes adquiridos!Tente novamente!";
		cout << "\nIntroduza o codigo dos pacotes que ja adquiriu(se nao adquiriu nenhum ou se vai adquirir agora um, digite -): ";
		getline(cin, aux);
	}
	novo.setPacotAdquiridos(pac);
	cout << "Introduza o capital gasto: ";
	getline(cin, aux);
	//verifica se ocorreu algum erro
	while (validnum(aux, capgasto) == false) {
		cerr << "\nIntroduziu carateres invalidos no campo capital gasto!Tente novamente!";
		cout << "\nIntroduza o capital gasto: ";
		getline(cin, aux);
	}
	novo.setCapGasto(capgasto);
	cliente.push_back(novo);
}

//altera o conteudo de um cliente
//@param1 vetor que contem informaÃ§ao dos clietes e e alterado
//@param2 vetor  que contem informaÃ§ao sobre pacotes
//@param3 string com informacao do ultimo a ser criado
void altcli(vector <Client> & cliente, vector <Pacotes> pacote, string imp) {
	char cont;
	int opcao, indice;   //indice guarda o indice do cliente a alterar, opcao para o que pretende alterar
	string nome, rua, nif, agreg, pac, porta, localidade, codpostal, andar, capgasto;  //auxilia a leitura de dados
	string aux;    //auxilia a leitura de dados
	cout << "\n\n##########################################################################################";
	cout << endl << "\n\t\t\tALTERACAO DE CLIENTES\n";
	//mostra os nomes dos clientes
	for (int i = 0; i < cliente.size(); i++) {
		cout << i + 1 << ")" << cliente[i].getNome() << ";" << endl;
	}
	cout << "\nIntroduza a opcao referente ao cliente que pretende alterar: ";
	cin >> indice;
	//deteta se houve erro
	while (indice < 1 || indice > cliente.size() || cin.fail()) {
		cin.clear();
		cin.ignore(1000, '\n');
		cerr << "\nOpcao invalida!Tente novamente: ";
		cin >> indice;
	}
	cin.ignore(1000, '\n');
	cout << endl << endl;
	cout << "\n\nPARAMETRO A ALTERAR\n\n1)Nome;\n2)Nif;\n3)Morada;\n4)Agregado Familiar;\n5)Pacotes Adquiridos;\n6)Capital Gasto;";
	cout << "\n\nIntroduza a sua opcao: ";
	cin >> opcao;
	//deteta se houve erro
	while (cin.fail() || opcao < 1 || opcao > 6) {
		cin.clear();
		cin.ignore(1000, '\n');
		cerr << "\nOpcao Invalida!Tente novamente: ";
		cin >> opcao;
	}
	cin.ignore(1000, '\n');
	//caso tenha selecionado a opcao morada mostra os disponiveis para alterar dentro deste parametro
	if (opcao == 3) {
		cout << "\n\nMORADA\n\n1)Rua;\n2)Porta;\n3)Codigo Postal;\n4)Andar;\n5)Localidade;";
		cout << "\n\nIntroduza a sua opcao: ";
		cin >> opcao;
		//verifica opcao valida?
		while (cin.fail() || opcao < 1 || opcao > 5) {
			cin.clear();
			cin.ignore(1000, '\n');
			cerr << "\nOpcao Invalida!Tente novamente: ";
			cin >> opcao;
		}
		cin.ignore(1000, '\n');
		cout << endl;
		switch (opcao) {
		case 1:
			cout << "Introduza a rua: ";
			getline(cin, aux);
			//verifica se ocorreu algum erro
			while (validname(normalise(aux)) == false) {
				cerr << "\nIntroduziu carateres invalidos no campo rua!Tente novamente!";
				cout << "\nIntroduza a rua: ";
				getline(cin, aux);
			}
			espaint(normalise(aux), rua);
			cliente[indice - 1].setMoradaRua(rua);
			break;
		case 2:
			cout << "Introduza o numero da porta: ";
			getline(cin, aux);
			//verifica se ocorreu algum erro
			while (validnum(aux, porta) == false) {
				cerr << "\nIntroduziu carateres invalidos no campo portaTente novamente!";
				cout << "\nIntroduza o numero da porta: ";
				getline(cin, aux);
			}
			cliente[indice - 1].setMoradaPorta(porta);
			break;
		case 3:
			cout << "Introduza o codigo postal: ";
			getline(cin, aux);
			//verifica se ocorreu algum erro
			while (validcodpostal(aux, codpostal) == false) {
				cerr << "\nIntroduziu carateres invalidos no campo codigo postal!Tente novamente!";
				cout << "\nIntroduza o codigo postal: ";
				getline(cin, aux);
			}
			cliente[indice - 1].setMoradaCPostal(codpostal);
			break;
		case 4:
			cout << "Introduza o andar: ";
			getline(cin, aux);
			//verifica se ocorreu algum erro
			while (validandar(aux, andar) == false) {
				cerr << "\nIntroduziu carateres invalidos no campo andar!Tente novamente!";
				cout << "\nIntroduza o andar: ";
				getline(cin, aux);
			}
			cliente[indice - 1].setMoradaAndar(andar);
			break;
		case 5:
			cout << "Introduza a localidade: ";
			getline(cin, aux);
			//verifica se ocorreu algum erro
			while (validname(normalise(aux)) == false) {
				cerr << "\nIntroduziu carateres invalidos no campo localidade!Tente novamente!";
				cout << "\nIntroduza a localidade: ";
				getline(cin, aux);
			}
			espaint(normalise(aux), localidade);
			cliente[indice - 1].setMoradaLocalidade(localidade);
			break;
		default:
			cout << " ";
		}
	}
	else {
		cout << endl << endl;
		switch (opcao) {
		case 1:
			cout << "Introduza o nome: ";
			getline(cin, aux);
			//verifica se ocorreu algum erro
			while (validname(normalise(aux)) == false) {
				cerr << "\nIntroduziu carateres invalidos no campo nome!Tente novamente!";
				cout << "\nIntroduza o nome: ";
				getline(cin, aux);
			}
			espaint(normalise(aux), nome);
			cliente[indice - 1].setNome(nome);
			break;
		case 2:
			cout << "Introduza o NIF: ";
			getline(cin, aux);
			//verifica se ocorreu algum erro
			while (validnum(aux, nif) == false || nif.length() != 9) {
				if (validnum(aux, nif) == false) {
					cerr << "\nIntroduziu carateres invalidos no campo NIF!Tente novamente!";
					cout << "\nIntroduza o NIF: ";
					getline(cin, aux);
				}
				else if (nif.length() < 9) {
					cerr << "\nIntroduziu carateres a menos no campo NIF!Tente novamente!";
					cout << "\nIntroduza o NIF: ";
					getline(cin, aux);
				}
				else {
					cerr << "\nIntroduziu carateres a mais no campo NIF!Tente novamente!";
					cout << "\nIntroduza o NIF: ";
					getline(cin, aux);
				}
			}
			cout << nif;
			cliente[indice - 1].setNif(nif);
			break;
		case 4:
			cout << "Introduza o agregado familiar: ";
			getline(cin, aux);
			//verifica se ocorreu algum erro
			while (validnum(aux, agreg) == false) {
				cerr << "\nIntroduziu carateres invalidos no campo agregado familiar!Tente novamente!";
				cout << "\nIntroduza o agregado familiar: ";
				getline(cin, aux);
			}
			cliente[indice - 1].setAgregFamiliar(agreg);
			break;
		case 5:
			cout << "Introduza os pacotes adquiridos(todos eles, digite - para nenhum pacote): ";
			getline(cin, aux);
			//verifica se ocorreu algum erro
			while (validpacadq(aux, pac) == false) {
				cerr << "\nIntroduziu carateres invalidos no campo pacotes adquiridos!Tente novamente!";
				cout << "\nIntroduza o codigo dos pacotes que ja adquiriu(se nao adquiriu nenhum ou se vai adquirir agora um, digite -): ";
				getline(cin, aux);
			}
			cliente[indice - 1].setPacotAdquiridos(pac);
			break;
		case 6:
			cout << "Introduza o capital gasto: ";
			getline(cin, aux);
			while (validnum(aux, capgasto) == false) {
				cerr << "\nIntroduziu carateres invalidos no campo capital gasto!Tente novamente!";
				cout << "Introduza o capital gasto: ";
				getline(cin, aux);
			}
			cliente[indice - 1].setCapGasto(capgasto);
		default:
			cout << " ";
		}
	}
}

//remove um cliente
//@param1 vetor que contem informaÃ§ao dos clietes e e alterado
//@param2 vetor  que contem informaÃ§ao sobre pacotes
//@param3 string com informacao do ultimo a ser criado
void remcli(vector <Client> & cliente, vector <Pacotes> pacote, string imp) {
	char cont;
	int indice;
	cout << "\n\n##########################################################################################";
	cout << endl << "\n\t\t\tREMOCAO DE CLIENTES\n";
	//mostra os nomes dos clientes
	for (int i = 0; i < cliente.size(); i++) {
		cout << i + 1 << ")" << cliente[i].getNome() << ";" << endl;
	}
	cout << "\nIntroduza a opcao referente ao cliente que pretende remover: ";
	cin >> indice;
	//deteta se houve erro
	while (indice < 1 || indice > cliente.size() || cin.fail()) {
		cin.clear();
		cin.ignore(1000, '\n');
		cerr << "\nOpcao invalida!Tente novamente: ";
		cin >> indice;
	}
	cin.ignore(1000, '\n');
	cliente.erase(cliente.begin() + (indice - 1));
}

//---------------------PACOTES-------------------------------

//cria novos pacotes
//@param1 vetor com informacao dos clientes
//@param2 vetor com informacao dos pacotes que e alterado
//@param3 string com informacao do ultimo a ser criado que vai ser alterado
void cripac(vector <Client> cliente, vector <Pacotes> & pacote, string & imp) {
	char cont;
	string aux, aux1, aux2;    //auxiliar a leitura de dados
	Pacotes novo;
	string ano, mes, dia;      //auxiliar a leitura de dados
	vector <string> codigos;
	string preco, lugdisp, lugocu, codigo, destino;     //auxiliar a leitura de dados
	int opcao;
	bool invalid = true, pres;
	cout << "\n\n##########################################################################################";
	cout << endl << endl << "\t\t\tCRIACAO DE PACOTES\n\n";
	//verifica se ja existe algum pacote com aqule codigo
	while (invalid) {
		cout << "Introduza o codigo do pacote: ";
		getline(cin, aux);
		if (validnum(aux, codigo) == false)
			cerr << "\nIntroduziu carateres invalidados no campo codigo!Tente novamente!\n";
		else {
			codigos = codvector(pacote);
			pres = (invector(codigos, codigo) || invector(codigos, "-" + codigo)); //verifica se ja a algum pacote com aquele codigo
				//se nao cria o codigo e coloca a string que guarda a informacao do ultimo pacote a ser criado com aquele valor
			if (pres == false) {
				novo.setId(codigo);
				imp = novo.getId();
				invalid = false;
			}
			//se sim informa utilizador
			else
				cerr << "\nJa existe um pacote com esse codigo!Tente novamente!\n";
		}
	}
	invalid = true;
	cout << "Introduza o destino: ";
	getline(cin, aux);
	//verifica se ocorreu algum erro
	while (validdest(normalise(aux), destino) == false) {
		cerr << "\nIntroduziu carateres no campo destino!Tente novamente!";
		cout << "\nIntroduza o destino: ";
		getline(cin, aux);
	}
	novo.setDestino(destino);
	// ve se as datas inseridas foram validas
	while (invalid) {
		cout << "Introduza a nova data de inicio no formato ano/mes/dia: ";
		getline(cin, aux, '/');
		getline(cin, aux1, '/');
		getline(cin, aux2);
		while (!validdigit(aux, aux1, aux2, ano, mes, dia)) {
			cerr << "\nIntroduziu carateres invalidos no campo data! Tente novamente!\n";
			cout << "Introduza a data de partida no formato ano/mes/dia: ";
			getline(cin, aux, '/');
			getline(cin, aux1, '/');
			getline(cin, aux2);
		}
		//se inserirmos 6  fica 06
		if (mes.length() == 1)
			mes = "0" + mes;
		if (dia.length() == 1)
			dia = "0" + dia;
		//verifica se a data existe
		if (validdate(stoi(ano), stoi(mes), stoi(dia)) == false) {
			invalid = true;
			cerr << "\nData Invalida!Tente novamente!\n";
		}
		else
			invalid = false;
	}
	//adiciona as datas
	novo.setAnoInicio(ano);
	novo.setMesInicio(mes);
	novo.setDiaInicio(dia);
	invalid = true;
	//ve se as datas sao validas
	while (invalid) {
		cout << "Introduza a nova data de chegada no formato ano/mes/dia: ";
		getline(cin, aux, '/');
		getline(cin, aux1, '/');
		getline(cin, aux2);
		while (!validdigit(aux, aux1, aux2, ano, mes, dia)) {
			cerr << "\nIntroduziu carateres invalidos no campo data! Tente novamente!\n";
			cout << "Introduza a data de partida no formato ano/mes/dia: ";
			getline(cin, aux, '/');
			getline(cin, aux1, '/');
			getline(cin, aux2);
		}
		//se inserirmos 6  fica 06
		if (mes.length() == 1)
			mes = "0" + mes;
		if (dia.length() == 1)
			dia = "0" + dia;
		//verifica se a data existe
		if (validdate(stoi(ano), stoi(mes), stoi(dia)) == false) {
			invalid = true;
			cerr << "\nData Invalida!Tente novamente!\n";
		}
		else if (stoi(ano + mes + dia) < stoi(novo.getAnoInicio() + novo.getMesInicio() + novo.getDiaInicio())) {
			invalid = true;
			cerr << "\nData Invalida!Tente novamente!\n";
		}
		else
			invalid = false;
	}
	//adiciona as datas
	novo.setAnoFim(ano);
	novo.setMesFim(mes);
	novo.setDiaFim(dia);
	cout << "Introduza o preco: ";
	getline(cin, aux);
	//verifica se ocorreu algum erro
	while (validnum(aux, preco) == false) {
		cerr << "\nIntroduziu carateres invalidos no campo preco!Tente novamente";
		cout << "\nIntroduza o preco: ";
		getline(cin, aux);
	}
	novo.setPreco(preco);
	cout << "Introduza a lotacao de lugares: ";
	getline(cin, aux);
	//verifica se ocorreu algum erro
	while (validnum(aux, lugdisp) == false) {
		cerr << "\nIntroduziu carateres invalidos no campo lotacao de lugares!Tente novamente";
		cout << "\nIntroduza a lotacao de lugares: ";
		getline(cin, aux);
	}
	novo.setLugares(lugdisp);
	cout << "Introduza o numero de lugares ocupados: ";
	getline(cin, aux);
	//verifica se ocorreu algum erro ou se os lugares ocupados sao mais que a lotacao que definimos
	while (validnum(aux, lugocu) == false || lugocu > novo.getLugares()) {
		if (validnum(aux, lugocu) == false) {
			cerr << "\nIntroduziu carateres invalidos no campo lugares ocupados!Tente novamente";
			cout << "\nIntroduza o numero de lugares ocupados: ";
			getline(cin, aux);
		}
		else {
			cerr << "\nNao e possivel os lugares ocupados serem mais do que a lotacao e lugares atual, " << novo.getLugares() << "!Tente novamente!";
			cout << "\nIntroduza o numero de lugares ocupados: ";
			getline(cin, aux);
		}

	}
	novo.setLugaresV(lugocu);
	pacote.push_back(novo);
}

//altera pacotes
//@param1 vetor com informacao dos clientes
//@param2 vetor com informacao dos pacotes que e alterado
//@param3 string com informacao do ultimo a ser criado
void altpac(vector <Client> cliente, vector <Pacotes> & pacote, string & imp)
{
	char cont;
	int indice, opcao;
	bool invalid = true, pres;
	vector <string> codigos;
	string ano, mes, dia;// auxilia a leitura de dados
	string aux, aux1, aux2;    // auxilia a leitura de dados
	string preco, lugdisp, lugocu, codigo, destino;// auxilia a leitura de dados
	int count;
	cout << "\n\n##########################################################################################";
	cout << endl << "\n\t\t\tALTERACAO DE PACOTES\n";
	//mostra todos os pacotes
	for (int i = 0; i < pacote.size(); i++) {
		cout << "Pacote " << i + 1 << endl << endl;
		pacote[i].showPacote();
		cout << endl << endl;
	}
	cout << "Introduza a opcao referente ao numero do pacote que pretende alterar: ";
	cin >> indice;
	//deteta se a opcao e valida
	while (cin.fail() || indice > pacote.size() || indice < 1) {
		cin.clear();
		cin.ignore(1000, '\n');
		cout << "\nOpcao Invalida!Tente novamente: ";
		cin >> indice;
	}
	cin.ignore(1000, '\n');
	cout << endl << endl;
	//pergunta qual e a opcao
	cout << "\n\nPARAMETRO A ALTERAR\n\n1)Codigo;\n2)Destino;\n3)Data de Inicio;\n4)Data de Fim;\n5)Preco;\n6)Lotacao dos lugares;\n7)Lugares ocupados;";
	cout << "\n\nIntroduza a sua opcao: ";
	cin >> opcao;
	//verifica se e valida
	while (cin.fail() || opcao < 1 || opcao > 7) {
		cin.clear();
		cin.ignore(1000, '\n');
		cout << "\nOpcao Invalida!Tente novamente: ";
		cin >> opcao;
	}
	cin.ignore(1000, '\n');
	cout << endl << endl;
	switch (opcao) {
	case 1:
		//verifica se a algum pacote com aquele codigo
		while (invalid) {
			cout << "Introduza o codigo do pacote: ";
			getline(cin, aux);
			while (lecopac(aux, codigo) == false) {
				cerr << "\nIntroduziu carateres invalidados no campo codigo!Tente novamente!";
				cout << "\nIntroduza o codigo do pacote: ";
				getline(cin, aux);
			}
			codigos = codvector(pacote);
			pres = (invector(codigos, codigo) || invector(codigos, "-" + codigo));
			if (pres == false) {
				if (pacote[indice - 1].getId() == imp) {
					pacote[indice - 1].setId(codigo);
					imp = pacote[indice - 1].getId();
				}
				else
					pacote[indice - 1].setId(codigo);
				invalid = false;
			}
			else {
				cerr << "\nJa existe um pacote com esse codigo!Insira outro codigo ou entao volte ao menu principal e altere o do outro!";
				cout << "\n\n1)Inserir outro codigo;"
					<< "\n2)Menu Principal;";
				cout << "\n\nSelecione uma das opcoes: ";
				cin >> opcao;
				while (opcao < 1 || opcao > 2 || cin.fail()) {
					cin.clear();
					cin.ignore(1000, '\n');
					cout << "\nOpcao Invalida!Tente novamente: ";
					cin >> opcao;
				}
				cout << endl;
				cin.ignore(1000, '\n');
				if (opcao == 2)
					invalid = false;
			}
		}
		break;
	case 2:
		cout << "Introduza o novo destino: ";
		getline(cin, aux);
		//verifica se ocorreu algum erro
		while (validdest(normalise(aux), destino) == false) {
			cerr << "\nIntroduziu carateres no campo destino!Tente novamente!";
			cout << "\nIntroduza o destino: ";
			getline(cin, aux);
		}
		pacote[indice - 1].setDestino(destino);
		break;
	case 3:
		//verifica se a nova data e valida
		while (invalid) {
			cout << "Introduza a data de inicio no formato ano/mes/dia: ";
			getline(cin, aux, '/');
			getline(cin, aux1, '/');
			getline(cin, aux2);
			while (!validdigit(aux, aux1, aux2, ano, mes, dia)) {
				cerr << "\nIntroduziu carateres invalidos no campo data! Tente novamente!\n";
				cout << "Introduza a data de partida no formato ano/mes/dia: ";
				getline(cin, aux, '/');
				getline(cin, aux1, '/');
				getline(cin, aux2);
			}
			//caso o utlizador tenha colocado por exmeplo 7 isto cloca 07
			if (mes.length() == 1)
				mes = "0" + mes;
			if (dia.length() == 1)
				dia = "0" + dia;
			//verifica se a data existe
			if (validdate(stoi(ano), stoi(mes), stoi(dia)) == false) {
				invalid = true;
				cerr << "\nData Invalida!Tente novamente!\n";
			}
			else if (stoi(ano + mes + dia) > stoi(pacote[indice - 1].getAnoFim() + pacote[indice - 1].getMesFim() + pacote[indice - 1].getDiaFim())) {
				invalid = true;
				cerr << "\nData Invalida!Tente novamente!\n";
			}
			else
				invalid = false;
		}
		pacote[indice - 1].setAnoInicio(ano);
		pacote[indice - 1].setMesInicio(mes);
		pacote[indice - 1].setDiaInicio(dia);
		break;
	case 4:
		//verifica se a nova data e valida
		while (invalid) {
			cout << "Introduza a data de chegada no formato ano/mes/dia: ";
			getline(cin, aux, '/');
			getline(cin, aux1, '/');
			getline(cin, aux2);
			while (!validdigit(aux, aux1, aux2, ano, mes, dia)) {
				cerr << "\nIntroduziu carateres invalidos no campo data! Tente novamente!\n";
				cout << "Introduza a data de chegada no formato ano/mes/dia: ";
				getline(cin, aux, '/');
				getline(cin, aux1, '/');
				getline(cin, aux2);
			}
			//caso o utlizador tenha colocado por exmeplo 7 isto cloca 07
			if (mes.length() == 1)
				mes = "0" + mes;
			if (dia.length() == 1)
				dia = "0" + dia;
			//verifica se a data existe
			if (validdate(stoi(ano), stoi(mes), stoi(dia)) == false) {
				invalid = true;
				cerr << "\nData Invalida!Tente novamente!\n";
			}
			//verifica se a data de chegada e antes da de partida
			else if (stoi(ano + mes + dia) < stoi(pacote[indice - 1].getAnoInicio() + pacote[indice - 1].getMesInicio() + pacote[indice - 1].getDiaInicio())) {
				invalid = true;
				cerr << "\nData Invalida!Tente novamente!\n";
			}
			else
				invalid = false;
		}
		pacote[indice - 1].setAnoFim(ano);
		pacote[indice - 1].setMesFim(mes);
		pacote[indice - 1].setDiaFim(dia);
		break;
	case 5:
		cout << "Introduza o preco: ";
		getline(cin, aux);
		//verifica se ocorreu algum erro
		while (validnum(aux, preco) == false) {
			cerr << "\nIntroduziu carateres invalidos no campo preco!Tente novamente";
			cout << "\nIntroduza o preco: ";
			getline(cin, aux);
		}
		pacote[indice - 1].setPreco(preco);
		break;
	case 6:
		cout << "Introduza a lotacao de lugares: ";
		getline(cin, aux);
		//verifica se ocorreu algum erro ou se os lugares ocupados eram mais que a lotacao de luagres
		while (validnum(aux, lugdisp) == false || lugdisp < pacote[indice - 1].getLugaresV()) {
			if (validnum(aux, lugdisp) == false) {
				cerr << "\nIntroduziu carateres invalidos no campo lotacao de lugares!Tente novamente";
				cout << "\nIntroduza a lotacao de lugares: ";
				getline(cin, aux);
			}
			else {
				cerr << "\nNao pode haver menor lotacao de lugares do que numero lugares ocupados atual, " << pacote[indice - 1].getLugaresV() << "!Tente novamente";
				cout << "\nIntroduza a lotacao de lugares: ";
				getline(cin, aux);
			}
		}
		pacote[indice - 1].setLugares(lugdisp);
		break;
	case 7:
		cout << "Introduza o numero de lugares ocupados: ";
		getline(cin, aux);
		//verifica se ocorreu algum erro ou se os lugares ocupados eram mais que a lotacao de lugares
		while (validnum(aux, lugocu) == false || lugocu > pacote[indice - 1].getLugares()) {
			if (validnum(aux, lugocu) == false) {
				cerr << "\nIntroduziu carateres invalidos no campo lugares ocupados!Tente novamente";
				cout << "\nIntroduza o numero de lugares ocupados: ";
				getline(cin, aux);
			}
			else {
				cerr << "\nNao podem haver mais lugares ocupados do que a lotacao de lugares atual, " << pacote[indice - 1].getLugares() << "!Tente novamente";
				cout << "\nIntroduza o numero de lugares ocupados: ";
				getline(cin, aux);
			}
		}
		pacote[indice - 1].setLugaresV(lugocu);
		break;
	default:
		cout << " ";
	}
}

//remove um dos pacotes
//@param1 vetor com informacao dos clientes
//@param2 vetor com informacao dos pacotes
//@param3 string com informacao do ultimo a ser criado
void inpac(vector <Client> cliente, vector <Pacotes> & pacote, string & imp) {
	char cont;
	int indice;
	string codigo;
	vector <Pacotes> disponiveis;
	cout << "\n\n##########################################################################################";
	cout << endl << "\n\t\t\tINDISPONIBILIDADE DE PACOTES\n\n";
	//mostra os pacotes que estao disponiveis
	disponiveis = dispac(pacote);
	for (int i = 0; i < disponiveis.size(); i++) {
		cout << "Pacote " << i + 1 << endl << endl;
		disponiveis[i].showPacote();
		cout << endl << endl;
	}
	cout << "Introduza a opcao referente ao codigo que pretende remover: ";
	cin >> indice;
	//deteta se a opao e valida
	while (cin.fail() || indice < 1 || indice > disponiveis.size()) {
		cin.clear();
		cin.ignore(1000, '\n');
		cout << "\nOpcao Invalida!Tente novamente: ";
		cin >> indice;
	}
	codigo = disponiveis[indice - 1].getId();
	//codigo do pacote a alterar
	indice = indexcod(codvector(pacote), codigo);
	if (imp == pacote[indice].getId())                     //se o ultimo a ser criado foi esse altera o numero no topo tambem
		imp = "-" + imp;
	pacote[indice].setId("-" + pacote[indice].getId());
	cin.ignore(1000, '\n');
}

//comprar um pacote
//@param1 vetor com informacao dos clientes
//@param2 vetor com informacao dos pacotes
//@param3 string com informacao do ultimo a ser criado
void compac(vector <Client> & cliente, vector <Pacotes> & pacote, string imp) {
	string aux;
	vector <string> codigos;
	int indicecli, indicepac, sobra; //indicecli: indice relativo ao cliente; indicepac: relativo ao pacote
	string verif;
	bool cont;
	cout << "\n\n##########################################################################################";
	cout << "\n\n\t\t\tCOMPRA DE PACOTES";
	//pretende saber se ja e ou nao cliente
	cout << endl << endl << "Ja e cliente(s/n)? ";
	cin >> aux;
	//verifica a opcao
	while (normalise(aux) != "s" && normalise(aux) != "n") {
		cerr << "\nErro! Por favor digite uma das opcoes indicadas(s/n): ";
		cin >> aux;
	}
	//se nao chama a funcao pra criar cliente 
	if (aux == "n") {
		cricli(cliente, pacote, imp);
		indicecli = cliente.size() - 1; //indice relativo ao novo cliente pois foi o ultimo a ser criado
	}
	//se sim
	else {
		//mostra os cliente existentes
		mostranomes(cliente);
		cout << "\nQual cliente e voce? Digite o numero correspondente a sua opcao: ";
		cin >> indicecli;
		//deteta se a opcao e valida
		while (indicecli < 1 || indicecli > cliente.size() || cin.fail()) {
			cin.clear();
			cin.ignore(1000, '\n');
			cout << "\nOpcao Invalida! Tente novamente: ";
			cin >> indicecli;
		}
		cin.ignore(1000, '\n');
		indicecli = indicecli - 1;  //indice relativo ao cliente detetado a  partir da opcao do utiliador
	}
	//mostra os pacotes disponiveis ao cliente
	disp(cliente, pacote, imp);
	cout << "\n\n##########################################################################";
	cout << "\n\n\t\t\tDE VOLTA A COMPRA DE PACOTES\n\n";
	//vetor dos codigos
	codigos = codvector(pacote);
	do {
		cout << "Introduza o numero do codigo do pacote referente a sua opcao: ";
		cin >> verif;
		//verifica se a opcao e valida se de facto o codigo que inseriu existe 
		while (!invector(codigos, verif)) {
			cout << "Nao ha nenhum pacote com esse codigo!Tente novamente: ";
			cin >> verif;
		}
		cin.ignore(1000, '\n');
		indicepac = indexcod(codigos, verif);    //vai ver qual e o indice do pacote no meio de todos os codigos disponiveis e nao disponiveis
		sobra = stoi(pacote[indicepac].getLugares()) - stoi(pacote[indicepac].getLugaresV());    //ve quantos lugares sobram
		//verifica se o cliente tem um agregado familiar superior ao numero de lugares disponiveis
		// se sim faz isto
		if (sobra < stoi(cliente[indicecli].getAgregFamiliar())) {
			cout << "\nApenas existem " << sobra << " lugares disponiveis neste pacote!Prentende apenas comprar estes lugares(s/n)? ";
			cin >> aux;
			//deteta se a opcao e valida
			while (normalise(aux) != "s" && normalise(aux) != "n") {
				cerr << "\nErro! Por favor digite uma das opcoes indicadas(s/n): ";
				cin >> aux;
			}
			//Se ele nao quiser comprar pergunta se pretende abandonar a opcao de compra
			if (normalise(aux) == "n") {
				cout << "\nPretende abandonar a opcao de compra(s/n)? ";
				cin >> aux;
				while (normalise(aux) != "s" && normalise(aux) != "n") {
					cerr << "\nErro! Por favor digite uma das opcoes indicadas(s/n): ";
					cin >> aux;
				}
				if (aux == "n")
					cont = false;
				else {
					cont = true;
					break;
				}
			}
			// Se quiser faz as alteracoes necessarias nos pacotes e clientes
			else {
				// se ele nao tiver nenhum adiciona o que comprou a lista de pacotes
				if (normalise(cliente[indicecli].getPacotAdquiridos()) == "-")
					cliente[indicecli].setPacotAdquiridos(pacote[indicepac].getId());
				//se tiver adiciona aos anteriores
				else if (!invector(tovector(cliente[indicecli].getPacotAdquiridos()), pacote[indicepac].getId()))
					cliente[indicecli].setPacotAdquiridos(cliente[indicecli].getPacotAdquiridos() + " ; " + pacote[indicepac].getId());
				//se ele acabar por esgotar o pacote poe o "-" no codigo deste e altera os lugares ocupados
				if (stoi(pacote[indicepac].getLugares()) <= (stoi(pacote[indicepac].getLugaresV()) + stoi(cliente[indicecli].getAgregFamiliar()))) {
					pacote[indicepac].setId("-" + pacote[indicepac].getId());
					pacote[indicepac].setLugaresV(pacote[indicepac].getLugares());
				}
				//se nao esgotar apenas altera os luagres ocupados
				else
					pacote[indicepac].setLugaresV(to_string(stoi(pacote[indicepac].getLugaresV()) + stoi(cliente[indicecli].getAgregFamiliar())));
				cont = true;
			}
		}
		//se nao tiver um agregado familiar superior faz isto
		else {
			cout << "\nTem a certeza que pretende comprar o pacote com o codigo " << pacote[indicepac].getId() << "(s/n)? ";
			cin >> aux;
			//deteta se a opcao e valida
			while (normalise(aux) != "s" && normalise(aux) != "n") {
				cerr << "Erro! Por favor digite uma das opcoes indicadas(s/n): ";
				cin >> aux;
			}
			//se afinal nao quiser comprar faz isto
			if (aux == "n")
				cont = false;
			//se quiser
			else {
				//Se nao tiver nenhum pacote aquirido mete aquele codigo na lista de pacotes adquiridos
				if (normalise(cliente[indicecli].getPacotAdquiridos()) == "-")
					cliente[indicecli].setPacotAdquiridos(pacote[indicepac].getId());
				//se tiver apenas adiciona a lista
				else if (!invector(tovector(cliente[indicecli].getPacotAdquiridos()), pacote[indicepac].getId()))
					cliente[indicecli].setPacotAdquiridos(cliente[indicecli].getPacotAdquiridos() + " ; " + pacote[indicepac].getId());
				//se esgotar o pacote poe "-" e altera os lugares ocupados
				if (stoi(pacote[indicepac].getLugares()) <= (stoi(pacote[indicepac].getLugares()) + stoi(cliente[indicecli].getAgregFamiliar()))) {
					pacote[indicepac].setId("-" + pacote[indicepac].getId());
					pacote[indicepac].setLugaresV(pacote[indicepac].getLugares());
				}
				//se nao esgotar apenas altera os lugares ocupados
				else
					pacote[indicepac].setLugaresV(to_string(stoi(pacote[indicepac].getLugaresV()) + stoi(cliente[indicecli].getAgregFamiliar())));
				cont = true;
			}
		}
	} while (!cont);
	cin.ignore(1000, '\n');
}


//-----------------------MENUS------------------------------

//Mostra menu com informÃ§ao dos pacotes disponiveis
//@param1 vetor com informaÃ§ao dos clientes
//@param2 vetor com informacao dos pacotes
//@param3 string com informacao do ultimo a ser criado
void pacotdisp(vector <Client> cliente, vector <Pacotes> pacote, string imp) {
	int opcao;
	cout << "\n\n##########################################################################################";
	cout << "\n\n\t\t\tPACOTES DISPONIVEIS\n\n1)Todos os Disponiveis;\n2)Destino Especifico;\n3)Entre duas datas;\n4)Destino Especifico entre duas datas;\n5)Voltar;";
	cout << "\n\nDigite o numero correspondente a sua opcao: ";
	cin >> opcao;
	while ((opcao < 1 || opcao > 5) || cin.fail()) {
		cin.clear();
		cin.ignore(1000, '\n');
		cerr << "\nOpcao invalida!Tente novamente: ";
		cin >> opcao;
	}
	cin.ignore(1000, '\n');
	switch (opcao) {
	case 1:
		disp(cliente, pacote, imp);
		break;
	case 2:
		destesp(cliente, pacote, imp);
		break;
	case 3:
		dudat(cliente, pacote, imp);
		break;
	case 4:
		destespdudat(cliente, pacote, imp);
		break;
	case 5:
		estatisticasmenu(cliente, pacote, imp);
		break;
	default:
		cout << " ";
	}

}

//Mostra menu com informaÃ§ao dos pacotes vendidos
//@param1 vetor com informaÃ§ao dos clientes
//@param2 vetor com informacao dos pacotes
//@param3 string com informacao do ultimo a ser criado
void vendinf(vector <Client> cliente, vector <Pacotes> pacote, string imp) {
	int opcao;
	cout << "\n\n##########################################################################################";
	cout << "\n\n\t\t\tPACOTES VENDIDOS-INFORMACOES\n\n1)Relativos a um cliente;\n2)Relativos a todos os clientes;\n3)Voltar\n\n";
	cout << "Digite o numero correspondente a sua opcao: ";
	cin >> opcao;
	while ((opcao < 1 || opcao > 3) || cin.fail()) {
		cin.clear();
		cin.ignore(1000, '\n');
		cerr << "\nOpcao invalida!Tente novamente: ";
		cin >> opcao;
		cout << endl;
	}
	cin.ignore(1000, '\n');
	switch (opcao) {
	case 1:
		clivend(cliente, pacote, imp);
		break;
	case 2:
		todvend(cliente, pacote, imp);
		break;
	case 3:
		estatisticasmenu(cliente, pacote, imp);
		break;
	default:
		cout << " ";
	}
}

//Mostra o Menu do Cliente
//@param1 vetor com informaÃ§ao sobre os clientes que e alterado
//@param2 vetor com informacao dos pacotes
//@param3 string com informacao do ultimo a ser criado
void clientemenu(vector <Client> & cliente, vector <Pacotes> pacote, string imp) {
	int opcao;
	cout << "\n\n##########################################################################################";
	cout << "\n\n\t\t\tGESTAO DE CLIENTES\n\n1)Criar;\n2)Alterar;\n3)Remover;\n4)Voltar;";
	cout << "\n\nDigite o numero correspondente a sua opcao: ";
	cin >> opcao;
	while ((opcao < 1 || opcao > 4) || cin.fail()) {
		cin.clear();
		cin.ignore(1000, '\n');
		cerr << "\nOpcao invalida!Tente novamente: ";
		cin >> opcao;
	}
	cin.ignore(1000, '\n');
	switch (opcao) {
	case 1:
		cricli(cliente, pacote, imp);
		break;
	case 2:
		altcli(cliente, pacote, imp);
		break;
	case 3:
		remcli(cliente, pacote, imp);
		break;
	case 4:
		menu(cliente, pacote, imp);
		break;
	default:
		cout << " ";
	}

}

//Mostra o menu dos pacotes
//@param1 vetor com informacao dos clientes
//@param2 vetor com informaÃ§ao dos pacotes que e alterado
//@param3 string que diz qual foi o ultimo a ser criado
void pacotemenu(vector <Client> cliente, vector <Pacotes> & pacote, string & imp) {
	int opcao;
	cout << "\n\n##########################################################################################";
	cout << "\n\n\t\t\tGESTAO DE PACOTES\n\n1)Criar;\n2)Alterar;\n3)Colocar Indisponivel;\n4)Voltar;";
	cout << "\n\nDigite o numero correspondente a sua opcao: ";
	cin >> opcao;
	while ((opcao < 1 || opcao > 4) || cin.fail()) {
		cin.clear();
		cin.ignore(1000, '\n');
		cerr << "\nOpcao invalida!Tente novamente: ";
		cin >> opcao;
	}
	cin.ignore(1000, '\n');
	switch (opcao) {
	case 1:
		cripac(cliente, pacote, imp);
		break;
	case 2:
		altpac(cliente, pacote, imp);
		break;
	case 3:
		inpac(cliente, pacote, imp);
		break;
	case 4:
		menu(cliente, pacote, imp);
		break;
	default:
		cout << " ";
	}

}

//Mostra o Menu para visualizaÃ§ao de dados
//@param1 vetor com informaÃ§ao dos clientes
//@param2 vetor com informaÃ§ao dos pacotes
//@param3 string com informacao do ultimo a ser criado
void estatisticasmenu(vector <Client> cliente, vector <Pacotes> pacote, string imp) {
	int opcao;
	cout << "\n\n##########################################################################################";
	cout << "\n\n\t\t\tMENU DE ESTATISTICAS\n\n1)Informacao sobre um cliente especifico;\n2)Informacao sobre todos os clientes;\n3)Informacao sobre os Pacotes Disponiveis;\n4)Informacao sobre quantos pacotes foram vendidos e o lucro;\n5)Informacao sobre pacotes vendidos;\n6)Voltar;";
	cout << "\n\nDigite o numero correspondente a sua opcao: ";
	cin >> opcao;
	while ((opcao < 1 || opcao > 6) || cin.fail()) {
		cin.clear();
		cin.ignore(1000, '\n');
		cerr << "\nOpcao invalida!Tente novamente: ";
		cin >> opcao;

	}
	cin.ignore(1000, '\n');
	switch (opcao) {
	case 1:
		clienteesp(cliente, pacote, imp);
		break;
	case 2:
		clienteger(cliente, pacote, imp);
		break;
	case 3:
		pacotdisp(cliente, pacote, imp);
		break;
	case 4:
		vendluc(cliente, pacote, imp);
		break;
	case 5:
		vendinf(cliente, pacote, imp);
		break;
	case 6:
		menu(cliente, pacote, imp);
		break;
	default:
		cout << " ";

	}

}

//Mostra o Menu Principal
//@param1 vetor com informaÃ§ao dos clientes que pode ser alterado
//@param2 vetor com informaÃ§ao dos pacotes que pode ser alterado
//@param3 string com informacao do ultimo a ser criado
void menu(vector <Client> & cliente, vector <Pacotes> & pacote, string & imp) {
	int opcao;
	cout << "\n\n##########################################################################################";
	cout << "\n\n\t\t\tMENU PRINCIPAL\n\n1)Gestao de Clientes;\n2)Gestao de Pacotes Turisticos;\n3)Visualizar Informacao;\n4)Compra de Pacotes;\n5)Sair;";
	cout << "\n\nDigite o numero correspondente a sua opcao: ";
	cin >> opcao;
	while ((opcao < 1 || opcao > 5) || cin.fail()) {
		cin.clear();
		cin.ignore(1000, '\n');
		cerr << "\nOpcao invalida!Tente novamente: ";
		cin >> opcao;
	}
	cin.ignore(1000, '\n');
	//mostra o menu
	switch (opcao) {
	case 1:
		clientemenu(cliente, pacote, imp);
		break;
	case 2:
		pacotemenu(cliente, pacote, imp);
		break;
	case 3:
		estatisticasmenu(cliente, pacote, imp);
		break;
	case 4:
		compac(cliente, pacote, imp);
		break;
	case 5:
		exit(1);
	default:
		cout << " ";
	}
}

//-----------------------------LER FICHEIROS------------------------------------------

//le os parametros que constituem o ficheira agencia para um vetor de strings
//@param1 vetor que vai acrescentar a informaÃ§ao da agencia
void leagencia(vector <Agency> & parametros) {
	string aux; //auxilia a leitura de dados
	Agency agencia;
	ifstream entrada;
	string fichagencia;  //variavel com o nome do ficheiro relativo a agencia
	cout << "Introduza o nome do ficheiro(com extensao) associado a agencia: ";
	getline(cin, fichagencia);
	entrada.open(normalise(fichagencia));
	//verifica se existe algum ficheiro com aquele nome
	while (normalise(fichagencia) == "" || cin.fail() || !entrada.is_open()) {
		if (cin.eof())
			cin.clear();
		cerr << "\nNao existe nenhum ficheiro com esse nome!\n";
		cout << "Introduza o nome do ficheiro(com extensao) associado a agencia: ";
		getline(cin, fichagencia);
		entrada.open(normalise(fichagencia));
	}
	/*while (cin.fail() || !entrada.is_open()) {
		if (cin.eof())
			cin.clear();
		cerr << "\nNao existe nenhum ficheiro com esse nome!\n";
		cout << "Introduza o nome do ficheiro(com extensao) associado a agencia: ";
		getline(cin, fichagencia);
		while (normalise(fichagencia) == "") {
			cerr << "\nNao existe nenhum ficheiro com esse nome!\n";
			cout << "Introduza o nome do ficheiro(com extensao) associado a agencia: ";
			getline(cin, fichagencia);
		}
		entrada.open(normalise(fichagencia));
	}*/
	//le a informacao para o vetor agencia
	getline(entrada, aux);
	agencia.setNome(aux);
	getline(entrada, aux);
	agencia.setNif(aux);
	getline(entrada, aux);
	agencia.setUrl(aux);
	getline(entrada, aux, '/');
	agencia.setAgenciaRua(aux);
	getline(entrada, aux, '/');
	agencia.setAgenciaPorta(aux);
	getline(entrada, aux, '/');
	agencia.setAgenciaAndar(aux);
	getline(entrada, aux, '/');
	agencia.setAgenciaCPostal(aux);
	getline(entrada, aux);
	agencia.setAgenciaLocalidade(aux);
	getline(entrada, aux);
	agencia.setFichCliente(aux);
	getline(entrada, aux);
	agencia.setFichPacotes(aux);
	parametros.push_back(agencia);
	entrada.close();
}

//le os parametros que constituem o ficheiro dos pacotes para um vetor de strings
//@param1 contem o nome do ficheiro
//@param2 vetor que vai acrescentar a informaÃ§ao dos pacotes
//@param3 ultimo pacote a ser criado
void lepacotes(string ficheiro, vector <Pacotes> & parametros, string & ultpac) {
	string lixo;   //serve para "meter" os : presentes para separar os pacotes
	Pacotes pacotes;
	int cont = 0;
	string aux, aux1, aux2, codigo, preco, lugocu, lugdisp, anoin, mesin, diain, anoche, mesche, diache, destino; //auxilia a leitura dos dados
	ifstream entrada;
	entrada.open(ficheiro);
	getline(entrada, aux);
	//verifica se houve algum erro com o codigo do ultimo pacote a ser criado ao ler do ficheiro
	if (lecopac(aux, ultpac) == false) {
		cerr << "Erro ao tentar ler do ficheiro " << ficheiro << " para o campo ultimo pacote a ser criado!"
			<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
		exit(1);
	}
	//ler do ficheiro
	while (getline(entrada, aux)) {
		//verifica se houve algum erro com o codigo do pacote ao ler do ficheiro
		if (lecopac(aux, codigo) == false) {
			cerr << "Erro ao tentar ler do ficheiro " << ficheiro << " para o campo codigo!"
				<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
			exit(1);
		}
		//adiciona ao vetor
		pacotes.setId(codigo);
		getline(entrada, aux);
		//verifica se houve algum erro com o destino do pacote ao ler do ficheiro e ja o cloca com o formato correto
		if (validdest(aux, destino) == false) {
			cerr << "Erro ao tentar ler do ficheiro " << ficheiro << " para o campo destino!"
				<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
			exit(1);
		}
		//adiciona ao vetor
		pacotes.setDestino(destino);
		getline(entrada, aux, '/');
		getline(entrada, aux1, '/');
		getline(entrada, aux2);
		//verifica se houve algum erro com a data de partida do pacote ao ler do ficheiro
		//neste primerio caso verifica se de facto esta la um numero
		if (validnum(aux, anoin) == false || validnum(aux1, mesin) == false || validnum(aux2, diain) == false) {
			cerr << "Erro ao tentar ler do ficheiro " << ficheiro << " para o campo data de inicio!"
				<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
			exit(1);
		}
		//verifica se a data existe
		else if (validdate(stoi(anoin), stoi(mesin), stoi(diain)) == false) {
			cerr << "Erro ao tentar ler do ficheiro " << ficheiro << " para o campo data de inicio!"
				<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
			exit(1);
		}
		getline(entrada, aux, '/');
		getline(entrada, aux1, '/');
		getline(entrada, aux2);
		//verifica se houve algum erro com a data de chegada do pacote ao ler do ficheiro
		//neste primerio caso verifica se de facto esta la um numero
		if (validnum(aux, anoche) == false || validnum(aux1, mesche) == false || validnum(aux2, diache) == false) {
			cerr << "Erro ao tentar ler do ficheiro " << ficheiro << " para o campo data de chegada!"
				<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
			exit(1);
		}
		//verifica se a data existe
		else if (validdate(stoi(anoche), stoi(mesche), stoi(diache)) == false) {
			cerr << "Erro ao tentar ler do ficheiro " << ficheiro << " para o campo data de chegada!"
				<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
			exit(1);
		}
		//verifica se a data de chegada e antes da de partida
		if (stoi(anoche + mesche + diache) < stoi(anoin + mesin + diain)) {
			cerr << "Erro ao tentar ler do ficheiro " << ficheiro << "!Data de partida nao pode ser depois da data de chegada!"
				<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
			exit(1);
		}
		//adiciona oa vetor
		pacotes.setDataInicio(diain, mesin, anoin);
		pacotes.setDataFim(diache, mesche, anoche);
		getline(entrada, aux);
		//verifica se houv algum erro ao lerdo ficheiro o preco
		if (validnum(aux, preco) == false) {
			cerr << "Erro ao tentar ler do ficheiro " << ficheiro << " para o campo preco!"
				<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
			exit(1);
		}
		//adiciona oa vetor
		pacotes.setPreco(preco);
		getline(entrada, aux);
		//verifica se houve algum erro com a lotacao de lugares ao ler do ficheiro
		if (validnum(aux, lugdisp) == false) {
			cerr << "Erro ao tentar ler do ficheiro " << ficheiro << " para o campo lotacao de lugares!"
				<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
			exit(1);
		}
		//adiciona ao vetor
		pacotes.setLugares(lugdisp);
		getline(entrada, aux);
		//verifica se houve algum erro ao ler do ficheiro os lugares ocupados ou se ha mais lugares ocupados do que a lotacao
		if (validnum(aux, lugocu) == false || stoi(lugocu) > stoi(lugdisp)) {
			cerr << "Erro ao tentar ler do ficheiro " << ficheiro << " para o campo lugares ocupados!"
				<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
			exit(1);
		}
		//adiciona ao vetor
		pacotes.setLugaresV(lugocu);
		getline(entrada, lixo);   //coloca o "lixo"
		parametros.push_back(pacotes);
	}
	entrada.close();
}

//le os parametros que constituem o ficheiro dos clientes para um vetor de strings
//@param1 contem o nome do ficheiro
//@param2 vetor que vai acrescentar a informaÃ§ao do cliente
void lecliente(string ficheiro, vector <Client> & parametros) {
	string lixo;      //serve para "meter" os : presentes para separar os pacotes
	ifstream entrada;
	entrada.open(ficheiro);
	Client cliente;
	string aux, nome, nif, agreg, rua, porta, localidade, andar, copostal, capgasto, pacadq; //auxilia a leitura de dados
	//ler do ficheiro
	while (getline(entrada, aux)) {
		//verifica se houve algum erro ao ler do ficheiro
		if (validname(aux) == false) {
			cerr << "Erro ao tentar ler do ficheiro " << ficheiro << " para o campo nome!"
				<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
			exit(1);
		}
		espaint(aux, nome);     //normaliza tira espacos a mais do meio e coloca em letra grande o necessario
		//adiciona ao vetor
		cliente.setNome(nome);
		getline(entrada, aux);
		//verifica se houve algum erro ao ler do ficheiro o nif
		if (validnum(aux, nif) == false) {
			cerr << "Erro ao tentar do ficheiro " << ficheiro << " para o campo nif!"
				<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
			exit(1);
		}
		//adiciona oa vetor
		cliente.setNif(nif);
		getline(entrada, aux);
		//verifica se houve algum erro ao ler do ficheiro o agregado familiar
		if (validnum(aux, agreg) == false) {
			cerr << "Erro ao tentar do ficheiro " << ficheiro << " para o campo agregado familiar!"
				<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
			exit(1);
		}
		//adiciona ao vetor
		cliente.setAgregFamiliar(agreg);
		getline(entrada, aux, '/');
		//verifica se houve algum erro ao ler do ficehiro a rua
		if (validname(aux) == false) {
			cerr << "Erro ao tentar do ficheiro " << ficheiro << " para o campo rua!"
				<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
			exit(1);
		}
		espaint(aux, rua);  //normaliza tira espacos a mais do meio e coloca em letra grande o necessario
		cliente.setMoradaRua(rua);    //adiciona ao vetor
		getline(entrada, aux, '/');
		//verifica se houve algum erro ao ler do ficehiro a porta
		if (validnum(aux, porta) == false) {
			cerr << "Erro ao tentar do ficheiro " << ficheiro << " para o campo porta!"
				<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
			exit(1);
		}
		cliente.setMoradaPorta(porta);   //adiciona   ao vetor
		getline(entrada, aux, '/');
		//verifica se houve algum erro ao ler do ficehiro o andar
		if (validandar(normalise(aux), andar) == false) {
			cerr << "Erro ao tentar do ficheiro " << ficheiro << " para o campo andar!"
				<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
			exit(1);
		}
		cliente.setMoradaAndar(andar);    //adiciona oa vetor
		getline(entrada, aux, '/');
		//verifica se houve algum erro ao ler do ficehiro codigo postal
		if (validcodpostal(aux, copostal) == false) {
			cerr << "Erro ao tentar do ficheiro " << ficheiro << " para o campo codigo postal!"
				<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
			exit(1);
		}
		cliente.setMoradaCPostal(copostal);   //adiciona ao vetor
		getline(entrada, aux);
		//verifica se houve algum erro ao ler do ficehiro a localidade
		if (validname(aux) == false) {
			cerr << "Erro ao tentar do ficheiro " << ficheiro << " para o campo rua!"
				<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
			exit(1);
		}
		espaint(aux, localidade);   //normaliza tira espacos a mais do meio e coloca em letra grande o necessario
		cliente.setMoradaLocalidade(localidade);   //adiciona ao vetor
		getline(entrada, aux);
		//verifica se houve algum erro ao ler do ficehiro pacotes adquiridos
		if (validpacadq(aux, pacadq) == false) {
			cerr << "Erro ao tentar do ficheiro " << ficheiro << " para o campo pacotes adquiridos!"
				<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
			exit(1);
		}
		cliente.setPacotAdquiridos(pacadq);
		getline(entrada, aux);
		//verifica se houve algum erro ao ler do ficehiro capital gasto
		if (validnum(aux, capgasto) == false) {
			cerr << "Erro ao tentar do ficheiro " << ficheiro << " para o campo capital gasto!"
				<< "\nPor favor corrija o ficheiro atual e reinicie o programa!\n";
			exit(1);
		}
		cliente.setCapGasto(capgasto);
		getline(entrada, lixo);
		parametros.push_back(cliente);
	}
	entrada.close();
}

//----------------------ATUALIZA FICHEIROS----------------------------------------------

//atualiza o ficheiro com informacao dos clientes criando um ficheiro adicional
//@param1 vetor com informacao dos clientes
//@param2 nome do ficheiro dos clientes
void atucli(vector <Client> cliente, string nome) {
	string aux;
	ofstream saida;
	//vai atualizar a informcao primeiramente para um ficheiro auxiliar para nao correr o risco de perder informacao
	saida.open("auxiliar");
	for (int i = 0; i < cliente.size(); i++) {
		saida << cliente[i].getNome() << endl;
		saida << cliente[i].getNif() << endl;
		saida << cliente[i].getAgregFamiliar() << endl;
		saida << cliente[i].getMoradaRua() << " / " << cliente[i].getMoradaPorta() << " / " << cliente[i].getMoradaAndar() << " / " << cliente[i].getMoradaCPostal() << " / " << cliente[i].getMoradaLocalidade() << endl;
		saida << cliente[i].getPacotAdquiridos() << endl;
		saida << cliente[i].getCapGasto() << endl;
		saida << "::::::::::" << endl;
	}
	saida.close();
	ifstream entrada;
	entrada.open("auxiliar");
	ofstream saida2;
	saida2.open(nome);
	//atualiza a informacao no ficheiro dos clientes original
	while (getline(entrada, aux)) {
		saida2 << aux << endl;
	}
	saida2.close();
	entrada.close();
}

//atualiza o ficheiro dos pacotes criando um ficheiro adicional
//@param1 recebe como parametro o vetor com informacao dos pacotes
//@param2 recebe como parametro uma string que diz qual foi o ultimo a ser criado
//@param3 nome do ficheiro dos pacotes
void atupac(vector <Pacotes> pacote, string imp, string nome) {
	string aux;
	ofstream saida;
	//vai atualizar a informcao primeiramente para um ficheiro auxiliar para nao correr o risco de perder informacao
	saida.open("auxiliar1");
	saida << imp << endl;
	for (int i = 0; i < pacote.size(); i++) {
		saida << pacote[i].getId() << endl;
		saida << pacote[i].getDestino() << endl;
		saida << pacote[i].getAnoInicio() << '/' << pacote[i].getMesInicio() << '/' << pacote[i].getDiaInicio() << endl;
		saida << pacote[i].getAnoFim() << '/' << pacote[i].getMesFim() << '/' << pacote[i].getDiaFim() << endl;
		saida << pacote[i].getPreco() << endl;
		saida << pacote[i].getLugares() << endl;
		saida << pacote[i].getLugaresV() << endl;
		saida << "::::::::::" << endl;
	}
	saida.close();
	ifstream entrada;
	entrada.open("auxiliar1");
	ofstream saida2;
	saida2.open(nome);
	//atualiza a informacao para o ficheiro dos pacotes original
	while (getline(entrada, aux)) {
		saida2 << aux << endl;
	}
	saida2.close();
	entrada.close();
}

//-------------------------MAIN----------------------------------------------------------

int main() {
	vector <Agency> paragencia;  //parametros da agencia
	vector <Client> paracliente;  //parametros do cliente
	vector <Pacotes> parapacotes;//parametros dos pacotes
	string imp, aux;     //imp guarda a informacao do ultimo pacote a ser criado, aux e apenas para auxiliar na leitura de dados
	bool cont = true;     //vai servir para guardar a informacao se o utilizador quer continuara ou nao com a execucao do programa
	leagencia(paragencia);
	lecliente(paragencia[0].getFichCliente(), paracliente);
	lepacotes(paragencia[0].getFichPacotes(), parapacotes, imp);
	//enquanto o utilizador quiser cintinuar com a execucao do programa
	while (cont) {
		menu(paracliente, parapacotes, imp);
		cout << "\n\n##########################################################################################";
		//cin.ignore(1000, '\n');
		cout << "\n\nQuer executar mais alguma operacao(s/n): ";
		getline(cin, aux);
		while ((normalise(aux) != "s" && normalise(aux) != "n") || cin.fail()) {
			if (cin.fail()) {
				cin.clear();
				//cin.ignore(1000, '\n');
			}
			cerr << "\nErro! Por favor digite uma das opcoes indicadas(s/n): ";
			getline(cin, aux);
		}
		if (aux == "n")
			cont = false;
	}
	atucli(paracliente, paragencia[0].getFichCliente());
	atupac(parapacotes, imp, paragencia[0].getFichPacotes());
	return 0;
}
